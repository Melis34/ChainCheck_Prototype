from findnode import *
"""
Checks for reentrancy
triggers critical vulnerability when found
"""




class ReentrancyChecker:
    def __init__(self, functions):
        
        """
        Initializes the ReentrancyChecker with a list of functions to analyze.
        :param functions: List of function definitions (extracted from the AST).
        """
        
        self.functions = functions

    def _analyze_function(self, func):
        """
        Analyzes a function's body for potential reentrancy vulnerabilities.
        :param func: A function node from the AST
        :return: List of reentrancy issues found in the function
        """
        issues = []
        calls= []
        assignments =[]
        # Safe check for the function body and statements
        statements = func.get("body", {}).get("statements", [])

        # Function to recursively check each child node
        def check_children(node):
            if isinstance(node, dict):
                # Check if the current node has the 'memberName' equal to "out"
                if node.get("memberName") in ["call", "delegatecall", "send", "transfer"]:
                    calls.append(node)
                    # print(f"Found 'call' at line {node.get('src', '')}")
                if node.get("nodeType") == "Assignment":
                    assignments.append(node)
                    # print(f"Found 'Assignment' at line {node.get('src', '')}")
                # Recurse into the children of the current node (nested dictionaries or lists)
                for key, value in node.items():
                    if isinstance(value, (dict, list)):
                        check_children(value)

            elif isinstance(node, list):
                # If it's a list, recurse through each item
                for item in node:
                    check_children(item)
        
        # Iterate over the statements and check for child nodes
        for statement in statements:
            check_children(statement)

        # Check if calls happen before the assignments
        for call in calls:
            for assignment in assignments:
                a = int(call.get("src").split(":")[0])
                b = int(assignment.get("src").split(":")[0])
               
                value_a = assignment.get("rightHandSide").get("name")
                value_a2 = assignment.get("leftHandSide").get("baseExpression").get("name")
                value_b = FindNode.find_node_by_id(func ,int(call.get("id")) + 1).get("name")
                value_b2 = FindNode.check_for_declarations(func, FindNode.find_node_by_id(func ,int(call.get("id")) + 1).get("name"))
                if value_b2 is not None:
                    value_b2 = value_b2.get("initialValue").get("baseExpression").get("name")
                if (a < b) :
                    if value_a == value_b or value_a2 == value_b2:
                        if value_a:
                            value = value_a
                        if value_a2:
                            value = value_a2
                        issues.append({"type": "Critical", "description": f"reentrancy found for value {value}"})
        return issues

   



    def detect_reentrancy(self):
        """
        Detects potential reentrancy vulnerabilities in the list of functions provided.
        :return: List of detected vulnerabilities (if any)
        """
        if not self.functions:
            print("No functions provided. Exiting.")
            return []

        # Analyze each function
        vulnerabilities = []
        for func in self.functions:
            func_name = func.get("name", "Unnamed Function")
            print("\033[100manalyzing function:" +"\033[0m" +" '" + func_name +"' for reentrancy ")
            issues = self._analyze_function(func)
            if issues:
                vulnerabilities.append({
                    "function": func_name,
                    "issues": issues
                })

        return vulnerabilities
