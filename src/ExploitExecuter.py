import os
import importlib
import inspect
from datetime import datetime
from compiler import parse_solidity
from extract_functions import extract_functions_from_ast

class ExploitExecutor:
    def __init__(self, functions):
        self.functions = functions
        self.vulnerabilities = []
        self.detect_after_functions = []

    def load_exploits(self, exploit_folder):
        # Load all exploits dynamically
        for file in os.listdir(exploit_folder):
            if file.endswith(".py") and not file.startswith("__"):
                module_name = f"exploits.{file[:-3]}"  # Module path
                try:
                    print(f"Loading exploit module: {module_name}...")
                    # Dynamically import the module
                    module = importlib.import_module(module_name)

                    # Find classes and call `detect_<exploitname>` methods
                    for name, obj in inspect.getmembers(module, inspect.isclass):
                        if name.endswith("Checker"):  # Assumes all checkers are named `*Checker`
                            checker_instance = obj(self.functions)

                            for method_name, method in inspect.getmembers(checker_instance, inspect.ismethod):
                                if method_name.startswith("detect_") and not method_name.startswith("detect_after_"):
                                    print(f"Running detection method: {method_name}...")
                                    results = method()
                                    if results:
                                        self.vulnerabilities.extend(results)
                                    else:
                                        print(f"No vulnerabilities found by {method_name}.")

                                # Collect detect_after_ methods for later execution
                                elif method_name.startswith("detect_after_"):
                                    self.detect_after_functions.append((checker_instance, method_name, method))

                except Exception as e:
                    print(f"Failed to load {module_name}: {e}")


class AfterDetectionRunner:
    def __init__(self, exploit_folder, vulnerabilities, files):
        self.exploit_folder = exploit_folder
        self.vulnerabilities = vulnerabilities
        self.files = files
        self.detect_after_functions = []

    def load_after_detection_exploits(self):
        """
        Dynamically load exploits from the given folder and collect `detect_after_` methods.
        """
        for file in os.listdir(self.exploit_folder):
            if file.endswith(".py") and not file.startswith("__"):
                module_name = f"exploits.{file[:-3]}"  # Module path
                try:
                    print(f"Loading exploit module: {module_name}...")
                    # Dynamically import the module
                    module = importlib.import_module(module_name)

                    # Find classes and call `detect_after_<exploitname>` methods
                    for name, obj in inspect.getmembers(module, inspect.isclass):
                        if name.endswith("Checker"):  # Assumes all checkers are named `*Checker`
                            checker_instance = obj(self.files)  # Pass `files` to the checker instance

                            for method_name, method in inspect.getmembers(checker_instance, inspect.ismethod):
                                if method_name.startswith("detect_after_"):
                                    print(f"Collecting after-detection method: {method_name}...")
                                    self.detect_after_functions.append((checker_instance, method_name, method))

                except Exception as e:
                    print(f"Failed to load {module_name}: {e}")

    def run(self):
        """
        Execute all `detect_after_` methods collected during loading.
        """
        # Load all `detect_after_` methods from exploits
        self.load_after_detection_exploits()

        # Execute `detect_after_` methods
        for instance, method_name, method in self.detect_after_functions:
            print(f"Running after-detection method: {method_name}...")

            try:
                if method_name.startswith("detect_after_w_ast_"):
                    result = method(self.vulnerabilities )
                else:
                    results = method(self.vulnerabilities)  # Pass the current vulnerabilities list

                if results:
                    for result in results:
                        self.vulnerabilities.append({
                            "function": "Post Scan",
                            "issues": [{"type": "Informational", "description": result}]
                        })

            except Exception as e:
                print(f"Error running {method_name}: {e}")
        return self.vulnerabilities



class ContractScanner:
    def __init__(self, file_path, exploit_folder):
        self.file_path = file_path
        self.exploit_folder = exploit_folder

    def scan(self):
        # Generate AST (Abstract Syntax Tree)
        ast = parse_solidity(self.file_path)

        if not ast:
            print("Failed to generate AST.")
            return

        # Extract all functions from the AST
        functions = extract_functions_from_ast(ast)

        if not functions:
            print("No functions found in the contract.")
            return

        # Create an ExploitExecutor to handle the actual exploit checks
        executor = ExploitExecutor(functions)
        executor.load_exploits(self.exploit_folder)

        # Run after-detection methods using AfterDetectionRunner
        # runner = AfterDetectionRunner(executor.detect_after_functions, executor.vulnerabilities, ast)
        # runner.run()

        return executor.vulnerabilities
